// Generated by CoffeeScript 1.6.3
(function() {
  var __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __slice = [].slice,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  (function($) {
    var $status, AgentList, Board, Colt, Game, Grenade, Grenades, HALF_PI, MouseTarget, PI, Player, QUARTER_PI, SPRITE_BOTTOM_PADDING, SQRT_2, Stats, Sword, TAU, Tracker, Weapon, Zombie, Zomgbie, abs, atan2, ceil, checkCollision, cos, floor, gravity, hypotenuse, lastRead, makeObservation, max, min, normalizeDirection, pick, pixelsPerMeter, pow, rand, read, round, sectorCoord, sectorRange, sectorSize, sin, sqrt, sum, _ref, _ref1, _ref2;
    sectorSize = 36;
    pixelsPerMeter = 36;
    gravity = 9.8 * pixelsPerMeter;
    abs = Math.abs;
    cos = Math.cos;
    sin = Math.sin;
    atan2 = Math.atan2;
    rand = Math.random;
    floor = Math.floor;
    ceil = Math.ceil;
    round = Math.round;
    sqrt = Math.sqrt;
    min = Math.min;
    max = Math.max;
    pow = Math.pow;
    PI = Math.PI;
    HALF_PI = PI / 2;
    QUARTER_PI = PI / 4;
    TAU = PI * 2;
    SQRT_2 = sqrt(2);
    SPRITE_BOTTOM_PADDING = 14;
    $status = $("<div>", {
      style: "position: relative; z-index: -1; overflow: hidden; width: 0; height: 0;",
      "aria-live": "polite",
      "role": "log"
    }).appendTo($(document.body));
    lastRead = new Date().getTime();
    read = function(text) {
      var now;
      now = new Date().getTime();
      if (!lastRead || now > lastRead + 1000) {
        lastRead = now;
        return $status.text(text);
      }
    };
    pick = function() {
      return arguments[floor(rand() * arguments.length)];
    };
    makeObservation = function() {
      read(pick("this is terrifying", "you're not doing very well", "this is hard to watch", "not bad", "pro tip: kill the zombies", "nicely done", "watch out", "look out", "here they come", "lol", "wow", "haha", "that was amazing", "good job", "gotta be quick", "you've got this", "you're a natural", "does my voice sound weird to you?", "i've got a bad feeling about this", "nice shooting, tex"));
      return setTimeout(makeObservation, 5000 + 1000 * floor(rand() * 20));
    };
    setTimeout(makeObservation, 10000);
    normalizeDirection = function(direction) {
      if (direction > PI) {
        direction -= TAU;
      } else if (direction < -PI) {
        direction += TAU;
      }
      return direction;
    };
    hypotenuse = function(a, b) {
      return sqrt(a * a + b * b);
    };
    checkCollision = function(otherX, otherY, otherSize, otherZ, otherHeight) {
      var distSquared, distX, distY, minDist, minDistSquared;
      distY = abs(this.y - otherY);
      minDist = (this.size + otherSize) / 2;
      minDistSquared = minDist * minDist;
      if (distY > minDist) {
        return false;
      }
      distX = abs(this.x - otherX);
      if (distX > minDist) {
        return false;
      }
      distSquared = distX * distX + distY * distY;
      if (distSquared > minDistSquared) {
        return false;
      }
      if (this.z !== otherZ && (this.z + this.height < otherZ || otherZ + otherHeight < this.z)) {
        return false;
      }
      return {
        direction: atan2(distY, distX),
        distSquared: distSquared
      };
    };
    sectorCoord = function(n) {
      return floor(n / sectorSize);
    };
    sectorRange = function(x, size) {
      if (x == null) {
        x = this.x;
      }
      if (size == null) {
        size = this.size;
      }
      if (x == null) {
        return;
      }
      return [sectorCoord(x - size / 2), sectorCoord(x + size / 2)];
    };
    sum = function(array) {
      var i, _i, _len;
      sum = 0;
      for (_i = 0, _len = array.length; _i < _len; _i++) {
        i = array[_i];
        sum += i;
      }
      return sum;
    };
    Zomgbie = function($canvas, options) {
      return new Game($canvas, options).run();
    };
    Game = (function() {
      function Game($canvas, options) {
        this.$canvas = $canvas;
        this.run = __bind(this.run, this);
        this.keyUp = __bind(this.keyUp, this);
        this.keyDown = __bind(this.keyDown, this);
        this.config = $.extend({}, this.config, options, true);
        this.board = new Board(this, $canvas);
        this.agents = new AgentList(this);
        this.mouseTarget = new MouseTarget(this.board);
        if (this.config.mode === 'observe') {
          this.config.patrolCorrection = 1;
          this.config.pursueTargets = false;
          this.addAllZombies();
        } else {
          this.stats = new Stats(this);
          this.player = new Player(this, this.mouseTarget);
          this.agents.push(this.player);
        }
        this.addListeners($canvas);
        this.setPursuitThreshold(this.config.pursuitThreshold);
        this.tickTime = floor(1000 / this.config.ticksPerSecond);
        this.times = {
          run: [],
          render: []
        };
      }

      Game.prototype.config = {
        ticksPerSecond: 30,
        maxZombies: 100,
        maxSpawnsPerTick: 50,
        pursuitThreshold: 200,
        patrolCorrection: 3,
        pursueTargets: true,
        mode: 'play',
        weapons: ['colt']
      };

      Game.prototype.addListeners = function() {
        var $doc,
          _this = this;
        $doc = $(document);
        this.$canvas.on('mousemove', function(e) {
          var _ref;
          _this.mouseTarget.set(e.clientX + 20, e.clientY * 2 + 160);
          return (_ref = _this.player) != null ? _ref.mouseMove() : void 0;
        });
        this.$canvas.on('mousedown', function(e) {
          var _ref;
          _this.mouseTarget.set(e.clientX + 20, e.clientY * 2 + 160);
          return (_ref = _this.player) != null ? _ref.mouseDown() : void 0;
        });
        this.$canvas.on('mouseup', function(e) {
          var _ref;
          _this.mouseTarget.set(e.clientX + 20, e.clientY * 2 + 160);
          return (_ref = _this.player) != null ? _ref.mouseUp() : void 0;
        });
        $doc.on('keydown', this.keyDown);
        $doc.on('keyup', this.keyUp);
        if (this.config.resize) {
          $(window).on('resize', this.board.resize);
        }
      };

      Game.prototype.keyDown = function(e) {
        var key, _ref;
        key = e.which;
        if ((_ref = this.player) != null) {
          _ref.keyDown(key);
        }
      };

      Game.prototype.keyUp = function(e) {
        var key, _ref;
        key = e.which;
        if ((_ref = this.player) != null) {
          _ref.keyUp(key);
        }
      };

      Game.prototype.time = function(label, code) {
        var ret, start, times;
        start = new Date().getTime();
        ret = code.call(this);
        times = this.times[label];
        if (times.length > 100) {
          times.shift();
        }
        times.push(new Date().getTime() - start);
        return ret;
      };

      Game.prototype.run = function() {
        var _base;
        if ((_base = this.times).nextTick == null) {
          _base.nextTick = this.times.started = new Date().getTime();
        }
        this.times.nextTick += this.tickTime;
        this.time('run', function() {
          this.maybeAddZombies();
          this.agents.move();
          return this.agents.sort();
        });
        this.time('render', function() {
          if (this.player) {
            return this.board.render(this.agents, this.player.weapons, this.stats);
          } else {
            return this.board.render(this.agents, this.mouseTarget);
          }
        });
        if (this.pursuitThreshold > this.config.pursuitThreshold) {
          this.setPursuitThreshold(this.pursuitThreshold - 2);
        }
        setTimeout(this.run, this.times.nextTick - new Date().getTime());
      };

      Game.prototype.addAllZombies = function() {
        var i, zombie, _i, _ref;
        for (i = _i = 0, _ref = this.config.maxZombies; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
          zombie = new Zombie(this, this.mouseTarget);
          zombie.randomStart(this.board);
          this.agents.push(zombie);
        }
      };

      Game.prototype.maybeAddZombies = function() {
        var agents, config, i, maxZombies, numZombies, toAdd, zombie, _i;
        agents = this.agents;
        config = this.config;
        numZombies = agents.numZombies;
        maxZombies = config.maxZombies;
        if (numZombies < maxZombies && rand() * 80 < 1) {
          toAdd = min(ceil(rand() * config.maxSpawnsPerTick), maxZombies - numZombies);
          if (rand() < 0.2) {
            if (toAdd === 1) {
              read(numZombies === 0 ? "zombie" : pick("another zombie", "yet another", "zombie", "walker"));
            } else if (toAdd < 4) {
              read(pick("zombies", "here they come", "here come a couple", "yikes"));
            } else {
              read(pick("uh oh", "oh no", "damn", "oh crap a lot of zombies", "here comes the horde", "whoa that's a lot", "they just keep coming"));
            }
          }
          for (i = _i = 0; 0 <= toAdd ? _i < toAdd : _i > toAdd; i = 0 <= toAdd ? ++_i : --_i) {
            zombie = new Zombie(this, this.player);
            zombie.randomEdgeStart(this.board);
            this.agents.push(zombie);
          }
        }
      };

      Game.prototype.gameOver = function() {
        var message, messages;
        messages = this.config.messages.gameOver;
        message = pick.apply(this, messages);
        read("game over. " + message);
        read = function() {};
        this.stats.setStatus(message);
      };

      Game.prototype.setPursuitThreshold = function(newVal) {
        this.pursuitThreshold = newVal;
        this.pursuitThresholdSquared = newVal * newVal;
      };

      Game.prototype.noise = function(factor) {
        if (factor == null) {
          factor = 1;
        }
        return this.setPursuitThreshold(min(this.pursuitThreshold + factor * this.config.pursuitThreshold, 3 * this.config.pursuitThreshold));
      };

      return Game;

    })();
    Board = (function() {
      function Board(game, $canvas) {
        this.game = game;
        this.resize = __bind(this.resize, this);
        this.canvas = $canvas[0];
        this.context = this.canvas.getContext('2d');
        this.resize();
      }

      Board.prototype.resize = function() {
        this.canvas.width = this.canvas.offsetWidth;
        this.canvas.height = this.canvas.offsetHeight;
        this.width = this.canvas.width;
        this.height = this.canvas.height * 2;
      };

      Board.prototype.render = function() {
        var arg, arg2, args, _i, _j, _len, _len1;
        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        this.context.clearRect(0, 0, this.width, this.height);
        for (_i = 0, _len = args.length; _i < _len; _i++) {
          arg = args[_i];
          if (arg.render) {
            arg.render(this);
            continue;
          }
          for (_j = 0, _len1 = arg.length; _j < _len1; _j++) {
            arg2 = arg[_j];
            arg2.render(this);
          }
        }
      };

      return Board;

    })();
    Stats = (function() {
      function Stats(game) {
        this.game = game;
      }

      Stats.prototype.kills = 0;

      Stats.prototype.killStreak = 0;

      Stats.prototype.maxKillStreak = 0;

      Stats.prototype.maxCombo = 0;

      Stats.prototype.hitRatio = 0;

      Stats.prototype.totalShots = 0;

      Stats.prototype.totalHitShots = 0;

      Stats.prototype.maxStatusTime = 150;

      Stats.prototype.addShotInfo = function(kills) {
        this.totalShots++;
        if (kills > 1 && kills > this.maxCombo) {
          this.maxCombo = kills;
        }
        this.kills += kills;
        if (kills) {
          this.totalHitShots++;
          this.killStreak += kills;
          if (this.killStreak > this.maxKillStreak) {
            this.maxKillStreak = this.killStreak;
          }
        } else {
          this.killStreak = 0;
        }
        this.hitRatio = this.totalHitShots / this.totalShots;
      };

      Stats.prototype.setStatus = function(status) {
        this.status = status;
        this.statusTime = this.maxStatusTime;
      };

      Stats.prototype.renderText = function(board, text, lineHeight, xAlign, yAlign) {
        var canvas, context, height, i, line, lines, metrics, newLines, width, x, y, _i, _len;
        canvas = board.canvas;
        width = canvas.width;
        context = board.context;
        lines = text.split("\n");
        i = 0;
        while (i < lines.length) {
          line = lines[i];
          metrics = context.measureText(line);
          if (metrics.width >= width) {
            newLines = this.wrapText(line, context, width);
            newLines.splice(0, 0, i, 1);
            i += newLines.length - 1;
            lines.splice.apply(lines, newLines);
          } else {
            i++;
          }
        }
        height = lines.length * lineHeight;
        x = 10;
        y = 5;
        if (xAlign === 'center') {
          x = width / 2;
        } else if (xAlign === 'right') {
          x = width - 10;
        }
        if (yAlign === 'center') {
          y = (canvas.height - height) / 2;
        } else if (yAlign === 'bottom') {
          y = canvas.height - height - 5;
        }
        context.textAlign = xAlign;
        for (_i = 0, _len = lines.length; _i < _len; _i++) {
          line = lines[_i];
          context.fillText(line, x, y);
          context.strokeText(line, x, y);
          y += lineHeight;
        }
      };

      Stats.prototype.wrapText = function(text, context, width) {
        var line, lines, metrics, testLine, word, words, _i, _len;
        words = text.split(/\s/);
        lines = [];
        line = '';
        for (_i = 0, _len = words.length; _i < _len; _i++) {
          word = words[_i];
          testLine = line + word + ' ';
          metrics = context.measureText(testLine);
          if (line && metrics.width > width) {
            lines.push(line);
            line = word + ' ';
          } else {
            line = testLine;
          }
        }
        lines.push(line);
        return lines;
      };

      Stats.prototype.renderDebug = function(board) {
        var agents, game, sector, sectorCount, sectors, tickTime, times;
        game = this.game;
        tickTime = game.tickTime;
        times = game.times;
        agents = game.agents;
        sectors = agents.sectors;
        sectorCount = 0;
        for (sector in sectors) {
          sectorCount++;
        }
        this.renderText(board, "sectors: " + sectorCount + "\nagents: " + agents.length + "\nrun: " + ((sum(times.run) / tickTime).toFixed(2)) + "%\nrender: " + ((sum(times.render) / tickTime).toFixed(2)) + "%", 30, "left", "top");
      };

      Stats.prototype.render = function(board) {
        var canvas, context, player, weapon;
        canvas = board.canvas;
        context = board.context;
        player = this.game.player;
        weapon = player.weapon;
        context.save();
        context.font = "bold 24px sans-serif";
        context.textBaseline = "top";
        context.globalAlpha = 0.6;
        context.fillStyle = player.alive ? '#800' : '#333';
        context.strokeStyle = '#000';
        if (this.game.config.debug) {
          this.renderDebug(board);
        }
        this.renderText(board, "kills: " + this.kills + "\nstreak: " + this.killStreak + " (" + this.maxKillStreak + ")\ncombo: " + this.maxCombo, 30, "left", "bottom");
        this.renderText(board, "walkers: " + this.game.agents.numZombies + "\n< weapon: " + weapon.name + " >\nammo: " + (weapon.shots && "...") + (weapon.cache ? " / " + weapon.cache : ""), 30, "right", "bottom");
        if (this.statusTime) {
          context.font = "bold 36px sans-serif";
          context.globalAlpha = 0.6 * min(1, 4 * this.statusTime / this.maxStatusTime);
          this.renderText(board, this.status, 42, "center", "center");
          this.statusTime--;
        }
        return context.restore();
      };

      return Stats;

    })();
    AgentList = (function() {
      function AgentList(game) {
        this.game = game;
        this.sectors = {};
        this.byStacking = [];
        this.byDistance = [];
      }

      AgentList.prototype.length = 0;

      AgentList.prototype.numZombies = 0;

      AgentList.prototype.push = function(item) {
        this.length++;
        this.byDistance.push(item);
        this.byStacking.push(item);
        return item;
      };

      AgentList.prototype.distanceSorterFrd = function(a, b) {
        return a.distSquaredFrd - b.distSquaredFrd;
      };

      AgentList.prototype.distanceSorter = function(a, b) {
        return a.distSquared - b.distSquared;
      };

      AgentList.prototype.stackingSorter = function(a, b) {
        return a.y - b.y;
      };

      AgentList.prototype.sort = function() {
        var byDistance, byStacking, i, _i, _ref;
        byDistance = this.byDistance;
        byStacking = this.byStacking;
        byDistance.sort(this.distanceSorterFrd);
        byStacking.sort(this.stackingSorter);
        for (i = _i = 0, _ref = this.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
          byDistance[i].distanceIdx = i;
          byStacking[i].stackingIdx = i;
        }
      };

      AgentList.prototype.remove = function(agent) {
        var byDistance, byStacking, i, len, _i, _j, _ref, _ref1;
        len = --this.length;
        byDistance = this.byDistance;
        byStacking = this.byStacking;
        byDistance.splice(agent.distanceIdx, 1);
        for (i = _i = _ref = agent.distanceIdx; _ref <= len ? _i < len : _i > len; i = _ref <= len ? ++_i : --_i) {
          byDistance[i].distanceIdx--;
        }
        byStacking.splice(agent.stackingIdx, 1);
        for (i = _j = _ref1 = agent.stackingIdx; _ref1 <= len ? _j < len : _j > len; i = _ref1 <= len ? ++_j : --_j) {
          byStacking[i].stackingIdx--;
        }
        this.removeFromSectors(agent, agent.sectorRange());
      };

      AgentList.prototype.bestMoveFor = function(agent, direction, distance) {
        var collision, currDir, currDist, currMove, factor, i, j, _i, _j;
        factor = rand() > 0.5 ? 1 : -1;
        for (i = _i = 0; _i < 4; i = ++_i) {
          currDist = (4 - i) / 4 * distance;
          for (j = _j = 0; _j < 7; j = ++_j) {
            currDir = normalizeDirection(direction + factor * (j % 2 || -1) * round(j / 2 + 0.25) * QUARTER_PI);
            if (currMove = this.validMoveFor(agent, currDir, currDist)) {
              if (i || j) {
                if (agent.deviations > 2) {
                  agent.rest(floor(rand() * 20), true);
                  break;
                }
                agent.deviations++;
              } else {
                agent.deviations = 0;
              }
              return {
                distance: currDist * currMove.factor,
                direction: currDir,
                x: currMove.x,
                y: currMove.y
              };
            }
          }
        }
        if (collision = this.closestCollision(agent)) {
          currDir = normalizeDirection(PI + collision.direction);
          return {
            distance: distance,
            direction: currDir,
            x: agent.x + 0.5 * distance * cos(currDir),
            y: agent.y + 0.5 * distance * sin(currDir)
          };
        }
      };

      AgentList.prototype.collisionsFor = function(agent, x, y, size) {
        var collision, collisions, height, i, other, range, sector, sectors, seen, z, _i, _j, _len, _ref, _ref1;
        if (x == null) {
          x = agent.x;
        }
        if (y == null) {
          y = agent.y;
        }
        if (size == null) {
          size = agent.size;
        }
        z = agent.z;
        height = agent.height;
        range = agent.sectorRange(x, size);
        sectors = this.sectors;
        collisions = [];
        seen = {};
        for (i = _i = _ref = range[0], _ref1 = range[1]; _ref <= _ref1 ? _i <= _ref1 : _i >= _ref1; i = _ref <= _ref1 ? ++_i : --_i) {
          sector = sectors[i];
          if (sector == null) {
            continue;
          }
          for (_j = 0, _len = sector.length; _j < _len; _j++) {
            other = sector[_j];
            if (!(other !== agent && !seen[other.distanceIdx])) {
              continue;
            }
            seen[other.distanceIdx] = true;
            if (collision = other.checkCollision(x, y, size, z, height)) {
              collisions.push({
                agent: other,
                distSquared: collision.distSquared,
                direction: collision.direction
              });
            }
          }
        }
        return collisions;
      };

      AgentList.prototype.closestCollision = function(agent) {
        var collisions;
        collisions = this.collisionsFor(agent);
        if (collisions.length) {
          collisions.sort(this.distanceSorter);
        }
        return collisions[0];
      };

      AgentList.prototype.validMoveFor = function(agent, direction, distance) {
        var collision, collisions, factor, other, x, y, _i, _len;
        x = agent.x + distance * cos(direction);
        y = agent.y + distance * sin(direction);
        factor = 1;
        if (agent !== this.game.player) {
          collisions = this.collisionsFor(agent, x, y);
          if (collisions.length) {
            for (_i = 0, _len = collisions.length; _i < _len; _i++) {
              collision = collisions[_i];
              other = collision.agent;
              if (other.decayTime) {
                factor = 0.2 * other.decayTime / other.maxDecayTime;
              } else if (other.sleepTime) {
                factor = 0.2;
              } else {
                return false;
              }
            }
          }
        }
        return {
          x: x,
          y: y,
          factor: factor
        };
      };

      AgentList.prototype.set = function(agent, x, y, z, size) {
        var rangeOld;
        if (z == null) {
          z = agent.z;
        }
        if (size == null) {
          size = agent.size;
        }
        if (agent.x === x && agent.y === y && agent.z === z && agent.size === size) {
          return;
        }
        rangeOld = agent.sectorRange();
        agent.x = x;
        agent.y = y;
        agent.z = z;
        agent.size = size;
        if (rangeOld) {
          this.setSectors(agent, rangeOld, agent.sectorRange());
        } else {
          this.addToSectors(agent, agent.sectorRange());
        }
      };

      AgentList.prototype.setSectors = function(agent, rangeOld, range) {
        var newEnd, newStart, oldEnd, oldStart, sectors;
        oldStart = rangeOld[0], oldEnd = rangeOld[1];
        newStart = range[0], newEnd = range[1];
        sectors = this.sectors;
        if (oldStart === newStart && oldEnd === newEnd) {
          return;
        }
        if (oldStart < newStart) {
          this.removeFromSectors(agent, [oldStart, min(newStart - 1, oldEnd)]);
        } else if (oldStart > newStart) {
          this.addToSectors(agent, [newStart, min(oldStart - 1, newEnd)]);
        }
        if (oldEnd > newEnd) {
          this.removeFromSectors(agent, [max(oldStart, newEnd + 1), oldEnd]);
        } else if (oldEnd < newEnd) {
          this.addToSectors(agent, [max(newStart, oldEnd + 1), newEnd]);
        }
      };

      AgentList.prototype.addToSectors = function(agent, range) {
        var i, sector, sectors, _i, _ref, _ref1;
        sectors = this.sectors;
        for (i = _i = _ref = range[0], _ref1 = range[1]; _ref <= _ref1 ? _i <= _ref1 : _i >= _ref1; i = _ref <= _ref1 ? ++_i : --_i) {
          sector = sectors[i] != null ? sectors[i] : sectors[i] = [];
          sector.push(agent);
        }
      };

      AgentList.prototype.removeFromSectors = function(agent, range) {
        var i, sector, sectors, _i, _ref, _ref1;
        sectors = this.sectors;
        for (i = _i = _ref = range[0], _ref1 = range[1]; _ref <= _ref1 ? _i <= _ref1 : _i >= _ref1; i = _ref <= _ref1 ? ++_i : --_i) {
          sector = sectors[i];
          sector.splice(sector.indexOf(agent), 1);
          if (!sector.length) {
            delete sectors[i];
          }
        }
      };

      AgentList.prototype.move = function() {
        var agent, byDistance, i, len, numZombies;
        numZombies = 0;
        byDistance = this.byDistance;
        len = this.length;
        i = 0;
        while (i < len) {
          agent = byDistance[i];
          if (!agent.nextMove()) {
            this.remove(agent);
            len--;
          } else {
            if (agent.alive && agent.zombie) {
              numZombies++;
            }
            i++;
          }
        }
        this.numZombies = numZombies;
      };

      AgentList.prototype.render = function(board) {
        var agent, _i, _j, _len, _len1, _ref, _ref1;
        _ref = this.byStacking;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          agent = _ref[_i];
          agent.renderShadow(board);
        }
        _ref1 = this.byStacking;
        for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
          agent = _ref1[_j];
          agent.render(board);
        }
      };

      return AgentList;

    })();
    Weapon = (function() {
      function Weapon(game, player) {
        this.game = game;
        this.player = player;
      }

      Weapon.factory = function(name, game, player) {
        var constructor, weapon;
        constructor = {
          colt: Colt,
          sword: Sword,
          grenades: Grenades
        }[name];
        weapon = new constructor(game, player);
        weapon.name = name;
        return weapon;
      };

      Weapon.prototype.ready = true;

      Weapon.prototype.disable = function(time, callback) {
        var _this = this;
        this.ready = false;
        setTimeout(function() {
          if (_this.player.alive) {
            _this.ready = true;
          }
          return callback.call(_this);
        }, time);
      };

      Weapon.prototype.closest = function() {
        var agent, _i, _len, _ref;
        _ref = this.game.agents.byDistance;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          agent = _ref[_i];
          if (agent.alive && agent.zombie) {
            return agent;
          }
        }
      };

      Weapon.prototype.render = function() {};

      Weapon.prototype.fire = function() {};

      Weapon.prototype.fired = function() {};

      return Weapon;

    })();
    Grenade = (function() {
      function Grenade(game) {
        this.explode = __bind(this.explode, this);
        var pin;
        this.game = game;
        this.player = game.player;
        this.pulledPin = new Date().getTime();
        this.gravityPerTick = gravity / game.config.ticksPerSecond;
        pin = this.sounds.pin;
        pin.load();
        pin.play();
        setTimeout(this.explode, this.timeToExplode);
      }

      Grenade.prototype.sounds = {
        pin: $('<audio src="audio/pin.mp3" preload="auto"></audio>')[0],
        hit: $('<audio src="audio/grenadehit.m4a" preload="auto"></audio>')[0],
        explode: $('<audio src="audio/explode.mp3" preload="auto"></audio>')[0]
      };

      Grenade.prototype.timeToExplode = 1500;

      Grenade.prototype.trackable = true;

      Grenade.prototype.killRadiusSquared = 60 * 60;

      Grenade.prototype.maimRadiusSquared = 120 * 120;

      Grenade.prototype.stunRadiusSquared = 200 * 200;

      Grenade.prototype.distractDiameter = 1000;

      Grenade.prototype.speed = 64;

      Grenade.prototype.size = 6;

      Grenade.prototype.decel = 12;

      Grenade.prototype.object = true;

      Grenade.prototype.distance = 0;

      Grenade.prototype.throwAt = function(target) {
        var dist, distX, distY, inertia, maxSpeed, optimalSpeed, optimalSpeedSide, player, relativeOptimalSpeed;
        if (this.exploded) {
          return;
        }
        player = this.player;
        this.thrown = true;
        this.set(player.x, player.y, 64);
        this.game.agents.push(this);
        if (target) {
          target = target.projectedLocation(this.timeToExplode + this.pulledPin - new Date().getTime());
          distX = target.x - this.x;
          distY = target.y - this.y;
          dist = hypotenuse(distX, distY);
          optimalSpeed = sqrt(dist * this.gravityPerTick) * 0.85;
          this.direction = atan2(distY, distX);
        } else {
          optimalSpeed = this.speed;
          this.direction = normalizeDirection(rand() * TAU);
        }
        optimalSpeedSide = optimalSpeed / SQRT_2;
        inertia = player.currentSpeed * cos(player.direction - this.direction);
        relativeOptimalSpeed = hypotenuse(optimalSpeedSide, optimalSpeedSide - inertia);
        maxSpeed = this.speed * (optimalSpeed / relativeOptimalSpeed);
        if (optimalSpeed > maxSpeed) {
          optimalSpeedSide *= maxSpeed / optimalSpeed;
        }
        this.zSpeed = optimalSpeedSide;
        this.speed = optimalSpeedSide;
        if (rand() < 0.25) {
          read(pick("nice throw", "good arm", "good throw", "nice", "you're nolan ryan"));
        }
      };

      Grenade.prototype.checkCollision = checkCollision;

      Grenade.prototype.animationTime = 240;

      Grenade.prototype.animationTimeExplosion = 15;

      Grenade.prototype.explode = function() {
        var agents, explode, hit, pin, player, sounds;
        agents = this.game.agents;
        sounds = this.sounds;
        pin = sounds.pin;
        hit = sounds.hit;
        explode = sounds.explode;
        pin.pause();
        hit.pause();
        explode.load();
        explode.play();
        if (!this.thrown) {
          player = this.player;
          this.thrown = true;
          this.set(player.x, player.y, 0);
          agents.push(this);
        }
        this.speed = 0;
        this.zSpeed = 0;
        this.exploded = true;
      };

      Grenade.prototype.caughtBy = function(agent) {
        if (agent.distractTime) {
          agent.distractTime = 1;
        }
      };

      Grenade.prototype.set = function(x, y, z, size) {
        this.game.agents.set(this, x, y, z, size);
      };

      Grenade.prototype.nextMove = function() {
        var agent, casualties, distractDiameter, game, hit, hitCount, info, killRadiusSquared, maimRadiusSquared, player, stunRadiusSquared, _i, _len,
          _this = this;
        if (this.exploded) {
          this.nextMove = function() {
            return --_this.animationTime;
          };
          this.set(this.x, this.y, this.z, 96);
          hitCount = 0;
          player = this.player;
          killRadiusSquared = this.killRadiusSquared;
          maimRadiusSquared = this.maimRadiusSquared;
          stunRadiusSquared = this.stunRadiusSquared;
          distractDiameter = this.distractDiameter;
          game = this.game;
          casualties = game.agents.collisionsFor(this, this.x, this.y, distractDiameter);
          for (_i = 0, _len = casualties.length; _i < _len; _i++) {
            info = casualties[_i];
            agent = info.agent;
            if (!agent.alive) {
              continue;
            }
            if (info.distSquared < killRadiusSquared) {
              agent.kill();
            } else if (info.distSquared < maimRadiusSquared) {
              agent.maim(floor(50 + 100 * (1 - info.distSquared / maimRadiusSquared)));
            } else if (agent !== this.player) {
              if (info.distSquared < stunRadiusSquared) {
                agent.stun(floor(25 + 50 * (1 - info.distSquared / stunRadiusSquared)));
              } else {
                agent.distract(this, 60 + floor(60 * rand()), distractDiameter);
              }
            }
          }
          game.noise(0.5);
          read(pick("hahaha", "awesome, " + hitCount, "got " + hitCount, "haha, you blew up " + hitCount, "ha, got " + hitCount, "that'll teach them", "it's raining arms", "i love grenades"));
          this.animationTime--;
        } else if (this.speed > 0) {
          this.z += this.zSpeed;
          if (this.z <= 0) {
            if (this.gravityPerTick) {
              hit = this.sounds.hit;
              hit.load();
              hit.play();
              this.gravityPerTick = 0;
            }
            this.z = 0;
            this.speed -= this.decel;
            if (this.speed < 0) {
              this.speed = 0;
            }
          } else {
            this.zSpeed -= this.gravityPerTick;
          }
          this.set(this.x + this.speed * cos(this.direction), this.y + this.speed * sin(this.direction));
        }
        return true;
      };

      Grenade.prototype.renderShadow = function(board) {
        var context, game, gradient, x, y;
        context = board.context;
        game = this.game;
        x = this.x;
        y = this.y;
        context.save();
        context.scale(1, 0.5);
        if (this.exploded) {
          context.globalAlpha = this.animationTime / Grenade.prototype.animationTime;
          context.beginPath();
          context.arc(x, y, 40, 0, TAU);
          gradient = context.createRadialGradient(x, y, 40, x, y, 0);
          gradient.addColorStop(0, 'rgba(0,0,0,0)');
          gradient.addColorStop(0.8, 'rgba(32,24,16,0.5)');
          gradient.addColorStop(1, 'rgba(32,24,16,1)');
          context.fillStyle = gradient;
          context.fill();
        } else {
          context.beginPath();
          context.globalAlpha = 0.2;
          context.arc(x, y, 3, 0, TAU);
          context.fillStyle = '#000';
          context.fill();
        }
        return context.restore();
      };

      Grenade.prototype.render = function(board) {
        var animationTime, b, circles, context, fade, g, gray, i, opacity, r, rad, size, x, y, _i;
        context = board.context;
        if (this.exploded) {
          animationTime = this.animationTimeExplosion - (Grenade.prototype.animationTime - this.animationTime);
          if (!(animationTime > 0)) {
            return;
          }
          context.save();
          fade = animationTime < 12 ? animationTime / 12 : 1;
          fade = fade * fade * fade;
          context.globalAlpha = fade;
          size = animationTime > 10 ? 3 * (16 - animationTime) : 5 + animationTime / 2;
          circles = size * 4;
          for (i = _i = 0; 0 <= circles ? _i < circles : _i > circles; i = 0 <= circles ? ++_i : --_i) {
            context.beginPath();
            rad = (1 + 2 * rand()) * size;
            x = (5 - 10 * rand()) * size;
            y = (2 - 4 * rand()) * size;
            y -= (1 - animationTime / 15) * 200;
            context.arc(this.x + x, this.y / 2 - this.z + y, rad, 0, TAU);
            gray = (1 - fade) * (96 + rand() * 128);
            r = floor(gray + fade * 255);
            g = floor(gray + fade * (192 + rand() * 64));
            b = floor(gray + fade * (rand() * 128));
            opacity = 0.5 * rand() + 0.1;
            context.fillStyle = 'rgba(' + r + ',' + g + ',' + b + ',' + opacity + ')';
            context.fill();
          }
          context.restore();
        } else {
          context.beginPath();
          context.arc(this.x, this.y / 2 - this.z - 3, 3, 0, TAU);
          context.fillStyle = '#080';
          context.fill();
          context.strokeStyle = '#000';
          context.stroke();
        }
      };

      Grenade.prototype.timeToThrow = function() {
        var elapsed;
        elapsed = new Date().getTime() - this.pulledPin;
        return 500 - elapsed;
      };

      Grenade.prototype.sectorRange = sectorRange;

      return Grenade;

    })();
    Grenades = (function(_super) {
      __extends(Grenades, _super);

      function Grenades() {
        this.fired = __bind(this.fired, this);
        _ref = Grenades.__super__.constructor.apply(this, arguments);
        return _ref;
      }

      Grenades.prototype.shots = '∞';

      Grenades.prototype.fire = function() {
        this.grenade = new Grenade(this.game);
        this.firing = true;
        this.ready = false;
      };

      Grenades.prototype.fired = function() {
        var grenade, wait;
        if (!this.firing) {
          return;
        }
        grenade = this.grenade;
        wait = grenade.timeToThrow();
        if (wait > 0) {
          setTimeout(this.fired, wait);
        } else {
          grenade.throwAt(this.closest());
          this.firing = false;
          this.ready = true;
        }
      };

      return Grenades;

    })(Weapon);
    Sword = (function(_super) {
      __extends(Sword, _super);

      function Sword() {
        _ref1 = Sword.__super__.constructor.apply(this, arguments);
        return _ref1;
      }

      Sword.prototype.shots = '∞';

      return Sword;

    })(Weapon);
    Colt = (function(_super) {
      __extends(Colt, _super);

      function Colt() {
        _ref2 = Colt.__super__.constructor.apply(this, arguments);
        return _ref2;
      }

      Colt.prototype.sounds = {
        fire: $('<audio src="audio/colt.mp3" preload="auto"></audio>')[0],
        reload: $('<audio src="audio/reload.m4a" preload="auto"></audio>')[0]
      };

      Colt.prototype.shots = 6;

      Colt.prototype.cache = '∞';

      Colt.prototype.maxVisibleTime = 5;

      Colt.prototype.fire = function() {
        var agent, agents, byDistance, closest, direction, fire, game, hitCount, hitMargin, len, offBy, player, _i, _len,
          _this = this;
        closest = this.closest();
        direction = rand() * TAU;
        player = this.player;
        game = this.game;
        agents = game.agents;
        byDistance = agents.byDistance;
        len = agents.length;
        fire = this.sounds.fire;
        hitCount = 0;
        game.noise();
        if (closest) {
          direction = closest.optimalDirection;
          direction += PI * (rand() / 45 - 1 / 90);
          for (_i = 0, _len = byDistance.length; _i < _len; _i++) {
            agent = byDistance[_i];
            if (!(agent.alive && agent !== player)) {
              continue;
            }
            hitMargin = abs(atan2(agent.size / 4, sqrt(agent.distSquaredFrd)));
            offBy = abs(agent.optimalDirection - direction);
            if (offBy < hitMargin) {
              hitCount++;
              agent.kill();
            }
          }
        }
        game.stats.addShotInfo(hitCount);
        direction = normalizeDirection(direction + PI);
        this.lastShot = {
          x: player.x,
          y: player.y,
          direction: direction,
          visibleTime: this.maxVisibleTime
        };
        this.shots--;
        if (hitCount === 0) {
          read(pick("miss", "whiff", "so close", "next time"));
        } else if (hitCount === 1) {
          read(pick("nice shot", "got one", "got 'em", "haha", "headshot"));
        } else {
          read(pick("oh wow", "got " + hitCount, "mega kill", hitCount + " for 1", "haha, amazing"));
        }
        fire.load();
        fire.play();
        this.disable(800, function() {
          if (!_this.shots) {
            return _this.reload();
          }
        });
      };

      Colt.prototype.reload = function() {
        var reload,
          _this = this;
        reload = this.sounds.reload;
        read(pick("reload quick", "quick", "hurry", "c'mon", "let's go", "faster", "oh man"));
        reload.load();
        reload.play();
        this.disable(3000, function() {
          return _this.shots = 6;
        });
      };

      Colt.prototype.render = function(board) {
        var context, direction, lastShot, x, y;
        context = board.context;
        lastShot = this.lastShot;
        if (lastShot != null ? lastShot.visibleTime : void 0) {
          x = lastShot.x, y = lastShot.y, direction = lastShot.direction;
          context.save();
          context.beginPath();
          context.moveTo(x, y / 2 - 40);
          context.lineTo(x + 600 * cos(direction), (y + 600 * sin(direction)) / 2 - 56);
          context.strokeStyle = '#ccc';
          context.globalAlpha = lastShot.visibleTime / this.maxVisibleTime;
          context.stroke();
          context.restore();
          lastShot.visibleTime--;
        }
      };

      return Colt;

    })(Weapon);
    Tracker = (function() {
      function Tracker(game, target) {
        this.target = target;
        this.game = game;
        this.agents = game != null ? game.agents : void 0;
      }

      Tracker.prototype.alive = true;

      Tracker.prototype.trackable = true;

      Tracker.prototype.size = 24;

      Tracker.prototype.pursuitWobble = 10;

      Tracker.prototype.patrolWobble = 30;

      Tracker.prototype.maxDecayTime = 160;

      Tracker.prototype.deviations = 0;

      Tracker.prototype.randomStart = function(board) {
        this.direction = normalizeDirection(rand() * TAU);
        this.set(rand() * board.width, rand() * board.height);
      };

      Tracker.prototype.randomEdgeStart = function(board) {
        var height, sprite, startPos, width;
        sprite = this.game.config.sprites[this.sprite];
        width = board.width;
        height = board.height;
        startPos = rand() * 2 * (width + height);
        if (startPos < width) {
          this.direction = HALF_PI;
          this.set(startPos, 0);
        } else if (startPos < width + height) {
          this.direction = PI;
          this.set(width + sprite.width / 2, startPos - width);
        } else if (startPos < 2 * width + height) {
          this.direction = 3 * HALF_PI;
          this.set(startPos - width - height, height + sprite.height * 2);
        } else {
          this.direction = 0;
          this.set(-sprite.width / 2, startPos - 2 * width - height);
        }
      };

      Tracker.prototype.render = function(board) {
        var context, decayTime, maxDecayTime, sprite;
        context = board.context;
        sprite = this.game.config.sprites[this.sprite];
        decayTime = this.decayTime;
        maxDecayTime = this.maxDecayTime;
        if (!(this.alive || decayTime)) {
          return;
        }
        if (decayTime || this.sleepTime) {
          context.save();
          if (decayTime) {
            context.globalAlpha = decayTime > maxDecayTime / 2 ? 1 : 2 * decayTime / maxDecayTime;
          }
          context.translate(round(this.x), round(this.y / 2));
          context.rotate(HALF_PI);
          context.drawImage(sprite, -sprite.width, -sprite.height / 2);
          context.restore();
        } else {
          context.drawImage(sprite, round(this.x - sprite.width / 2), round(this.y / 2 - sprite.height));
        }
      };

      Tracker.prototype.renderShadow = function(board) {
        var context, time, x, y;
        context = board.context;
        x = this.x;
        y = this.y - 2 * SPRITE_BOTTOM_PADDING;
        context.save();
        context.scale(1, 0.5);
        context.globalAlpha = 0.05;
        context.beginPath();
        context.arc(x, y, 10, 0, TAU);
        context.fillStyle = '#000';
        context.fill();
        if (time = this.sleepTime || this.decayTime) {
          if (this.blood == null) {
            this.blood = this.bloodStain();
          }
          context.globalAlpha = time / (this.totalSleepTime || this.maxDecayTime);
          context.drawImage(this.blood, x - 36, y - 36);
        }
        return context.restore();
      };

      Tracker.prototype.sectorRange = sectorRange;

      Tracker.prototype.bloodStain = function() {
        var canvas, circles, context, i, rad, size, x, y, _i;
        canvas = document.createElement('canvas');
        context = canvas.getContext('2d');
        canvas.width = 72;
        canvas.height = 72;
        circles = this.alive ? 5 : 10;
        size = 5;
        for (i = _i = 0; 0 <= circles ? _i < circles : _i > circles; i = 0 <= circles ? ++_i : --_i) {
          context.beginPath();
          rad = (1 + rand()) * size;
          x = 36 + 10 * (0.5 - rand()) * size;
          y = 36 + 5 * (0.5 - rand()) * size;
          context.arc(x, y, rad, 0, TAU);
          context.fillStyle = 'rgba(128,0,0,1)';
          context.fill();
        }
        return canvas;
      };

      Tracker.prototype.nextMove = function() {
        this.currentSpeed = 0;
        if (!this.alive) {
          if (this.decayTime) {
            this.decayTime--;
          }
          return this.decayTime;
        }
        this.checkProximity();
        if (this.sleepTime) {
          --this.sleepTime || (this.blood = null);
        } else if (this.manual && !this.restRequired) {
          this.manualMove();
        } else if (this.game.config.pursueTargets && this.targetVisible() && !this.restRequired) {
          this.pursue();
        } else if (this.restTime) {
          this.rest();
        } else if (rand() < 0.02) {
          this.rest(ceil(rand() * 40));
        } else {
          this.patrol();
        }
        return true;
      };

      Tracker.prototype.targetVisible = function() {
        var distX, distY, game, target, threshold, _ref3, _ref4;
        target = this.target;
        game = this.game;
        threshold = (_ref3 = this.pursuitThreshold) != null ? _ref3 : game.pursuitThreshold;
        distX = this.distX;
        distY = this.distY;
        if (!target || target.alive === false) {
          return false;
        }
        if (distX > threshold || distX < -threshold) {
          return false;
        }
        if (distY > threshold || distY < -threshold) {
          return false;
        }
        return this.distSquared < ((_ref4 = this.pursuitThresholdSquared) != null ? _ref4 : game.pursuitThresholdSquared);
      };

      Tracker.prototype.distract = function(fakeTarget, distractTime, distractRadius) {
        this.targetTrackTime = this.distractTime = distractTime;
        this.pursuitThreshold = distractRadius;
        this.pursuitThresholdSquared = distractRadius * distractRadius;
        if (this.targetFrd == null) {
          this.targetFrd = this.target;
        }
        this.target = fakeTarget;
      };

      Tracker.prototype.checkCollision = checkCollision;

      Tracker.prototype.checkProximity = function() {
        var correction, distX, distY, optimalDirection, projected, target, targetFrd, x, y, _ref3;
        target = this.target;
        if (target != null ? target.trackable : void 0) {
          x = this.x;
          y = this.y;
          if (this.distractTime) {
            targetFrd = (function() {
              if ((_ref3 = this.targetFrd) != null) {
                return _ref3;
              } else {
                debugger;
              }
            }).call(this);
            if (--this.distractTime) {
              distX = targetFrd.x - x;
              distY = targetFrd.y - y;
              this.distSquaredFrd = distX * distX + distY * distY;
            } else {
              this.target = target = targetFrd;
              this.targetFrd = null;
              this.pursuitThreshold = null;
              this.pursuitThresholdSquared = null;
            }
          }
          distX = this.distX = target.x - x;
          distY = this.distY = target.y - y;
          optimalDirection = this.optimalDirection = atan2(distY, distX);
          this.distSquared = distX * distX + distY * distY;
          if (!this.distractTime) {
            this.distSquaredFrd = this.distSquared;
          }
          if (this.predictFactor && target.currentSpeed) {
            if (abs(normalizeDirection(this.optimalDirection - target.direction)) < HALF_PI) {
              projected = target.projectedLocation(500);
              correction = this.predictFactor * normalizeDirection(atan2(projected.y - y, projected.x - x) - optimalDirection);
            } else {
              correction = this.predictFactor * normalizeDirection(PI - (target.direction - optimalDirection));
            }
            this.optimalDirection = normalizeDirection(optimalDirection + correction);
          }
        } else {
          this.targetTrackTime = 0;
        }
      };

      Tracker.prototype.wobble = function(degrees) {
        if (!degrees) {
          return 0;
        }
        return PI * (rand() * degrees / 90 - degrees / 180);
      };

      Tracker.prototype.manualMove = function() {
        var direction;
        direction = normalizeDirection(atan2(this.manualY, this.manualX));
        if (this.manualX || this.manualY) {
          this.move(direction, this.speed);
        }
      };

      Tracker.prototype.pursue = function() {
        var direction, distSquared, game, minCaptureDist, speed, speedSquared, target;
        if (this.targetTrackTime) {
          this.targetTrackTime--;
        } else {
          this.targetTrackTime = 120;
        }
        target = this.target;
        distSquared = this.distSquared;
        speed = this.speed;
        speedSquared = this.speedSquared;
        minCaptureDist = speed + (this.size + target.size) / 2;
        game = this.game;
        if (distSquared < minCaptureDist * minCaptureDist) {
          if (distSquared < speedSquared) {
            this.set(target.x, target.y);
          } else {
            this.move(this.optimalDirection, speed);
          }
          target.caughtBy(this);
          this.restTime = 20;
        } else {
          direction = normalizeDirection(this.optimalDirection + this.wobble(this.pursuitWobble));
          if (this !== game.player) {
            speed *= (1 + rand() + (1 - pow(min(1, distSquared / game.pursuitThresholdSquared), 2))) / 4;
          }
          this.move(direction, speed);
        }
      };

      Tracker.prototype.patrol = function() {
        var difference, direction;
        direction = normalizeDirection(this.direction + this.wobble(this.patrolWobble));
        if (this.target) {
          difference = normalizeDirection(this.optimalDirection - direction);
          if (abs(difference) > HALF_PI) {
            direction += (difference > 0 ? 1 : -1) * PI * this.game.config.patrolCorrection / 180;
          }
        }
        this.move(direction, this.speed / 3);
      };

      Tracker.prototype.rest = function(duration, required) {
        if (duration == null) {
          this.restTime--;
          if (!this.restTime) {
            return this.restRequired = false;
          }
        } else {
          this.restTime = duration;
          return this.restRequired = required;
        }
      };

      Tracker.prototype.move = function(direction, distance) {
        var frd;
        if (frd = this.agents.bestMoveFor(this, direction, distance)) {
          this.direction = frd.direction;
          this.currentSpeed = frd.distance;
          this.set(frd.x, frd.y);
        }
      };

      Tracker.prototype.set = function(x, y) {
        this.agents.set(this, x, y);
      };

      Tracker.prototype.kill = function() {
        this.alive = false;
        this.decayTime = this.maxDecayTime;
      };

      Tracker.prototype.maim = function(time) {
        this.totalSleepTime = this.sleepTime = floor(time);
      };

      Tracker.prototype.stun = function(time) {
        this.rest(time, true);
      };

      Tracker.prototype.projectedLocation = function(time) {
        var direction, projectedDist, ticks, x, y;
        ticks = time / this.game.tickTime;
        projectedDist = this.currentSpeed * ticks;
        direction = this.direction;
        x = this.x + projectedDist * cos(direction);
        y = this.y + projectedDist * sin(direction);
        return {
          x: x,
          y: y
        };
      };

      return Tracker;

    })();
    Zombie = (function(_super) {
      __extends(Zombie, _super);

      function Zombie(game, target) {
        Zombie.__super__.constructor.apply(this, arguments);
        this.speed = 0.5 * (1 + rand()) * this.maxSpeed;
        this.speedSquared = this.speed * this.speed;
        this.sprite = 1 + floor(rand() * 15);
        this.predictFactor = rand() * rand();
      }

      Zombie.prototype.maxSpeed = 6;

      Zombie.prototype.zombie = true;

      return Zombie;

    })(Tracker);
    MouseTarget = (function() {
      function MouseTarget(board) {
        this.board = board;
        this.x = board.width / 2;
        this.y = board.height / 2;
        this.mask = document.createElement('canvas');
        this.maskContext = this.mask.getContext('2d');
      }

      MouseTarget.prototype.trackable = true;

      MouseTarget.prototype.size = 0;

      MouseTarget.prototype.caughtBy = function() {};

      MouseTarget.prototype.set = function(x, y) {
        this.x = x;
        this.y = y;
      };

      MouseTarget.prototype.render = function(board) {
        var canvas, context, eyeOffset, gradient, height, mask, maskContext, radius, width, x, y;
        context = board.context;
        canvas = board.canvas;
        width = canvas.width;
        height = canvas.height;
        radius = min(width, height) / 5;
        eyeOffset = 0.7;
        gradient;
        x = this.x;
        y = this.y / 2;
        mask = this.mask;
        maskContext = this.maskContext;
        mask.width = width;
        mask.height = height;
        maskContext.clearRect(0, 0, width, height);
        gradient = maskContext.createRadialGradient(x - eyeOffset * radius, y, radius * 0.9, x - eyeOffset * radius, y, radius);
        gradient.addColorStop(0, 'rgba(0,0,0,0.95)');
        gradient.addColorStop(1, 'rgba(0,0,0,0)');
        maskContext.fillStyle = gradient;
        maskContext.arc(x - eyeOffset * radius, y, radius, 0, TAU);
        maskContext.fill();
        gradient = maskContext.createRadialGradient(x + eyeOffset * radius, y, radius * 0.9, x + eyeOffset * radius, y, radius);
        gradient.addColorStop(0, 'rgba(0,0,0,0.95)');
        gradient.addColorStop(1, 'rgba(0,0,0,0)');
        maskContext.fillStyle = gradient;
        maskContext.arc(x + eyeOffset * radius, y, radius, 0, TAU);
        maskContext.fill();
        maskContext.globalCompositeOperation = 'xor';
        maskContext.fillStyle = 'rgba(0,0,0,1)';
        maskContext.fillRect(0, 0, width, height);
        context.drawImage(mask, 0, 0);
      };

      return MouseTarget;

    })();
    Player = (function(_super) {
      __extends(Player, _super);

      function Player(game, mouseTarget) {
        var name;
        Player.__super__.constructor.apply(this, arguments);
        this.set(mouseTarget.x, mouseTarget.y);
        this.speedSquared = this.speed * this.speed;
        this.directionKeysPressed = {};
        this.weapons = (function() {
          var _i, _len, _ref3, _results;
          _ref3 = game.config.weapons;
          _results = [];
          for (_i = 0, _len = _ref3.length; _i < _len; _i++) {
            name = _ref3[_i];
            _results.push(Weapon.factory(name, game, this));
          }
          return _results;
        }).call(this);
        this.weapon = this.weapons[0];
      }

      Player.prototype.pursuitWobble = 0;

      Player.prototype.speed = 12;

      Player.prototype.direction = 0;

      Player.prototype.sprite = 0;

      Player.prototype.targetVisible = function() {
        return true;
      };

      Player.prototype.kill = function() {
        Player.__super__.kill.apply(this, arguments);
        this.weapon.ready = false;
        this.game.gameOver();
      };

      Player.prototype.infect = function() {
        var zombie;
        this.kill();
        this.decayTime = 0;
        zombie = new Zombie(this.game);
        zombie.sprite = 0;
        zombie.direction = 0;
        zombie.set(this.x, this.y + 1);
        zombie.maim(40);
        this.agents.push(zombie);
      };

      Player.prototype.caughtBy = function() {
        return this.infect();
      };

      Player.prototype.directionKeys = {
        37: 'W',
        38: 'N',
        39: 'E',
        40: 'S',
        65: 'W',
        87: 'N',
        68: 'E',
        83: 'S'
      };

      Player.prototype.inferManualDirection = function() {
        var directions, key;
        directions = {};
        for (key in this.directionKeysPressed) {
          if (this.directionKeysPressed[key]) {
            directions[this.directionKeys[key]] = 1;
          }
        }
        this.manualX = directions.E ^ directions.W ? directions.E || -1 : 0;
        this.manualY = directions.S ^ directions.N ? directions.S || -1 : 0;
      };

      Player.prototype.mouseDown = function() {
        if (this.alive && this.weapon.ready && !this.sleepTime) {
          this.weapon.fire();
        }
      };

      Player.prototype.mouseUp = function() {
        if (this.alive && this.weapon.firing && !this.sleepTime) {
          this.weapon.fired();
        }
      };

      Player.prototype.mouseMove = function() {
        if (this.manual && !this.manualX && !this.manualY) {
          this.manual = false;
        }
      };

      Player.prototype.keyDown = function(key) {
        if (!this.alive) {
          return;
        }
        if (this.directionKeys[key]) {
          this.manual = true;
          this.directionKeysPressed[key] = true;
          this.inferManualDirection();
        } else if (this.weapon.ready && !this.sleepTime) {
          if (key === 32) {
            this.weapon.fire();
          } else if (key === 188) {
            this.prevWeapon();
          } else if (key === 190) {
            this.nextWeapon();
          }
        }
      };

      Player.prototype.keyUp = function(key) {
        if (!this.alive) {
          return;
        }
        if (this.directionKeys[key]) {
          this.directionKeysPressed[key] = false;
          this.inferManualDirection();
        } else if (key === 32 && this.weapon.firing) {
          this.weapon.fired();
        }
      };

      Player.prototype.prevWeapon = function() {
        this.weapons.unshift(this.weapons.pop());
        this.weapon = this.weapons[0];
      };

      Player.prototype.nextWeapon = function() {
        this.weapons.push(this.weapons.shift());
        this.weapon = this.weapons[0];
      };

      Player.prototype.renderShadow = function(board) {
        var context;
        Player.__super__.renderShadow.apply(this, arguments);
        context = board.context;
        context.save();
        context.scale(1, 0.5);
        context.globalAlpha = 0.25;
        context.beginPath();
        context.arc(this.x, this.y - 2 * SPRITE_BOTTOM_PADDING, this.game.pursuitThreshold, 0, TAU);
        context.fillStyle = '#ffd';
        context.fill();
        context.restore();
      };

      return Player;

    })(Tracker);
    return window.Zomgbie = Zomgbie;
  })($);

}).call(this);
